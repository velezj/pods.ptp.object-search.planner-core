
void spnp_console_print_point_set( const std::vector<nd_point_t>& points,
				     const marked_grid_t<bool>& grid )
  {
    std::vector<marked_grid_cell_t> full_cells;
    for( size_t i = 0; i < points.size(); ++i ) {
      marked_grid_cell_t cell = grid.cell( points[i] );
      if( std::find( full_cells.begin(),
		     full_cells.end(),
		     cell ) == full_cells.end() ) {
	full_cells.push_back( cell );
      }
    }

    // Ok, now get all possible cells
    std::vector<marked_grid_cell_t> all_cells = grid.all_cells_ordered();
    
    // Print out the cells, in a grid format
    std::vector<std::string> barrier_characters;
    barrier_characters.push_back( "|" );
    barrier_characters.push_back( "~" );
    barrier_characters.push_back( "*" );
    int barrier_characters_len = barrier_characters.size();
    std::vector<std::string> end_characters;
    end_characters.push_back( "\n" );
    int end_characters_len = end_characters.size();
    char join_barrier_character = '+';
    std::string join_end_string = "\n\n";
    int barrier_spacing = 5;
    for( int i = 0; i < all_cells.size(); ++i ) {
      marked_grid_cell_t cell = all_cells[i];
      bool marked = (std::find( full_cells.begin(),
				full_cells.end(),
				cell ) != full_cells.end());
      
      // write out empoty of filled cell
      if( marked ) {
	std::cout << "v";
      } else {
	std::cout << "-";
      }

      // write out a barrier if needed,
      // first track how many barriers are reached (count) and 
      // the last index for a barrier
      int barrier_count = 0;
      int barrier_idx = 0;
      int end_count = 0;
      int end_idx = 0;
      nd_point_t start_point = centroid( grid.region( all_cells[0] ) );
      nd_point_t cell_point = centroid( grid.region( cell ) );
      for( int k = 0; k < start_point.n; ++k ) {
	double diff = abs(start_point.coordinate[k] - cell_point.coordinate[k]);
	double cell_size = grid.cell_sizes()[k];
	int grid_diff = (int)symmetric_round( diff / cell_size );
	if( grid_diff % barrier_spacing == 0 ) {
	  barrier_count++;
	  barrier_idx = k;
	}
	nd_vector_t dir = zero_vector( start_point.n );
	dir.component[k] = cell_size;
	if( is_inside( cell_point + dir, grid.window() ) == false ) {
	  ++end_count;
	  end_idx = k;
	}
      }

      // Ok, use join barrier if more that one reached, else
      // just use the indexed character for a single barrier
      if( barrier_count > 1 ) {
	std::cout << join_barrier_character;
      } else if( barrier_count == 1 ) {
	std::cout << barrier_characters[ barrier_idx % barrier_characters_len ];
      }

      // Write out end character if needed
      if( end_count > 1 ) {
	std::cout << join_end_string;
      } else if( end_count == 1 ) {
	std::cout << end_characters[ end_idx % end_characters_len ];
      }
    }
    std::cout.flush();
  }



int main()
{

  

  return 0;
}
